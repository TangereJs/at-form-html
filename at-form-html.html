<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="at-form-html-input-validation.html">
<link rel="import" href="../iron-label/iron-label.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../quill-element/quill-element.html">

<dom-module id="at-form-html">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      #hint {
        min-height: 14px;
        margin-bottom: 8px;
      }
    </style>
    <div id="atContainer" class="at-container">
      <iron-label id="label" for="quillElement">{{label}}</iron-label>
      <div id="contentContainer" class="at-content-container">
        <quill-element id="quillElement"></quill-element>
      </div>
      <div id="hint"></div>
    </div>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-form-html',
      behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormHtmlInputValidation],
      properties: {
        /**
         * Element's label for element display purposes
         * @property label
         * @type String
         * @default ''
         */
        label: {
          type: String,
          value: '',
          title: 'Label'
        },

        /**
         * Hides element's label
         * @property hideLabel
         * @type Boolean
         * @default false
         */
        hideLabel: {
          type: Boolean,
          value: false,
          observer: '_hideLabelChanged',
          title: 'Do not show the label'
        },

        /**
         * Element's disabled state
         * @property disabled
         * @type Boolean
         * @default false
         */
        disabled: {
          type: Boolean,
          value: false,
          observer: '_disabledChanged',
          title: 'Field value can not be changed'
        },

        /**
        * Hides the element. When hidden nothing is displayed for the element
        * @property hide
        * @type Boolean
        * @default false
        */
        hide: {
          type: Boolean,
          value: false,
          observer: '_hideChanged',
          title: 'Field is invisible'
        },

        /**
         * Element's required state for element validation purposes
         * @property required
         * @type Boolean
         * @default false
         */
        required: {
          type: Boolean,
          value: false,
          title: 'Input required'
        },

        /**
         * Maximum number of characters across all lines allowed on the element. Use 0 (zero) for no limit
         * @property maxLines
         * @type Number
         * @default 0
         */
        maxChars: {
          type: Number,
          value: 0,
          title: 'Maximum number of characters'
        },

        /**
         * Elements value
         * @property value
         * @type String
         * @default ''
         */
        value: {
          type: String,
          xtype: 'json',
          mode: 'json',
          value: "",
          observer: '_valueChanged',
          title: 'Value'
        },
      },

      observers: [
        '_internalValidStateUpdate(required, maxChars)'
      ],

      $meta: [{
        title: "Html",
        type: "string",
        xtype: "html"
      }],

      _hideLabelChanged: function(newValue, oldValue) {
        this.toggleClass("hidden", newValue, this.$.label);
      },

      ready: function() {

        var self = this;
        var quillElement = this.$.quillElement;
        quillElement.addEventListener('text-change', function(event) {
          if (self._ignoreQuillTextChanged) { return; }
          event.stopPropagation();
          self.validate();
        });

        this._isReady = true;
        this._valueChanged(this.value, "called from ready");
        this._internalValidStateUpdate(this.required, this.maxChars);
      },

      _disabledChanged: function(newValue, oldValue) {
        var label = this.$.label;
        this.toggleClass('disabled', newValue, label);
        var contentContainer = this.$.contentContainer;
        this.toggleClass('disabled', newValue, contentContainer);

        var quillElement = this.$.quillElement;
        if (this._isReady) {
          quillElement.disable(newValue);
        }
      },

      _hideChanged: function(newValue, oldValue) {
        var atContainer = this.$.atContainer;
        this.toggleClass('hidden', newValue, atContainer);
      },

      _internalValidStateUpdate: function (required, maxChars) {
        if (this._isReady) {
          this.validate();
        }
      },

      _valueChanged: function(newValue, oldValue) {
        if (!this._isReady) { return; }

        var valueToSet = [null, "null"].indexOf(newValue) !== -1 ? "" : newValue;
        var quillElement = this.$.quillElement;

        if (!this._isInternalUpdate) {
          this._ignoreQuillTextChanged = true;
          try {
            var parsedValue = JSON.parse(valueToSet);
            quillElement.setContents(parsedValue);
          } catch (e) {
            console.log(e);
          }
          this._ignoreQuillTextChanged = false;

          if (this.autoValidate) { this._validate(true); }
        }

        this._fireValueChangedEvent(this.value);
      },

      _getFocusableElement: function() {
        return this.$.quillElement;
      },

      focus: function () {
        this._getFocusableElement().focus();
      },

      validate: function (showError) {

        if (showError === undefined) { showError = this.autoValidate; }

        // validate must validate the current value
        var quillDelta = this.$.quillElement.getContents();
        var inputValue = JSON.stringify(quillDelta);
        var quillLength = this._getQuillDeltaLength(inputValue);

        if ([null, "null"].indexOf(this.value) !== -1 && quillLength > 1 )  {
          // if value is set to null but quill input is not empty set value to input value
          this._isInternalUpdate = true;
          this.value = inputValue;
          this._isInternalUpdate = false;
        } else if ([null, "null"].indexOf(this.value) === -1) {
          // if value is not null
          var valueQuillLength = this._getQuillDeltaLength(this.value);
          if (valueQuillLength !== quillLength || (valueQuillLength > 1 && this.value !== inputValue)) {
            this._isInternalUpdate = true;
            this.value = inputValue;
            this._isInternalUpdate = false;
          }
        }

        return this._validate(showError);
      },

      _validate: function (showError) {
        var validationResult = this._validateBaseData();
        this._handleValidationResult(validationResult);
        if (!validationResult.isValid) {
          return validationResult.isValid;
        }

        validationResult = this._validateData(this, this.value, this.T.bind(this));
        if (showError) { this._handleValidationResult(validationResult); }

        return validationResult.isValid;
      },

      _updateUIValidState: function(isValid) {
        var label = this.$.label;
        this.toggleClass('error', !isValid, label);
        var contentContainer = this.$.contentContainer;
        this.toggleClass('error', !isValid, contentContainer);
        var atContainer = this.$.atContainer;
        var codeMirrorCode = atContainer.getElementsByClassName('CodeMirror-lines')[0];
        this.toggleClass('error', !isValid, codeMirrorCode);
        var hint = this.$.hint;
        this.toggleClass('error', !isValid, hint);
      },

      _getQuillDeltaLength: function(quillDeltaAsJson) {
        function isArray(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        }

        try {
          var quillDeltaObj = JSON.parse(quillDeltaAsJson);
          var ops = quillDeltaObj.ops;
          if (!ops || !isArray(ops) || !ops.length) { return 1; }

          var totalLength = 0;
          ops.forEach(function(op, index) {
            totalLength += (op.insert.trim()).length;
          });

          return totalLength;
        } catch (e) {
          // due to how quilljs works delta length of 1 means empty value becase it contains only a single CRLF character
          return 1;
        }
      }

    });
  </script>
</dom-module>
